# -*- coding: utf-8 -*-
"""Deep Learning Fundamentals.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oa9xDqVv-6giiRznL9cnq58-3ovg55gF

**Coding the Neural Network Components**
"""

import numpy as np
age = 34
experience = 7

topnode_weights = [2, -5]
bottomnode_weights = [1, -2]
output_weights = [3, -1]

# Create NumPy arrays
input_layer = np.array([age, experience])
weights_topnode = np.array(topnode_weights)
weights_bottomnode = np.array(bottomnode_weights)
output_weights = np.array(output_weights)

# Print the values of the variables
print("input_layer:", input_layer)
print("weights_topnode:", weights_topnode)
print("weights_bottomnode:", weights_bottomnode)
print("output_weights:", output_weights)

"""**Coding the Output with Forward Propagation**"""

import numpy as np

# Define input layer and weights
input_layer = np.array([34, 7])
weights_topnode = np.array([2, -5])
weights_bottomnode = np.array([1, -2])
output_weights = np.array([3, -1])

# Calculate the value of the top node
top_node_value = np.sum(input_layer * weights_topnode)

# Calculate the value of the bottom node
bottom_node_value = np.sum(input_layer * weights_bottomnode)

# Print the node values
print("Top Node Value:", top_node_value)
print("Bottom Node Value:", bottom_node_value)

# Create a NumPy array for both node values
hidden_layer_values = np.array([top_node_value, bottom_node_value])

# Calculate the prediction
prediction = np.sum(hidden_layer_values * output_weights)

# Print the prediction value
print("Prediction:", prediction)

"""**Forward Propagation for Deeper Neural Network**"""

import numpy as np

# Define input layer and weights for each node
input_layer = np.array([34, 7])
weights_node_n1 = np.array([2, -5])
weights_node_n2 = np.array([1, -2])
weights_node_n3 = np.array([3, -2])
weights_node_n4 = np.array([1, -1])
output_weights = np.array([2, -6])

# Calculate the values of nodes n1 and n2 in the first hidden layer
n1 = np.sum(input_layer * weights_node_n1)
n2 = np.sum(input_layer * weights_node_n2)

# Store the values of the nodes in the first hidden layer in a NumPy array
layer_1_output = np.array([n1, n2])

# Print the value of layer_1_output
print("Layer 1 Output:", layer_1_output)

# Calculate the values of nodes n3 and n4 in the second hidden layer
n3 = np.sum(layer_1_output * weights_node_n3)
n4 = np.sum(layer_1_output * weights_node_n4)

# Store the values of the nodes in the second hidden layer in a NumPy array
layer_2_output = np.array([n3, n4])

# Print the value of layer_2_output
print("Layer 2 Output:", layer_2_output)

# Calculate the prediction by multiplying layer_2_output by output_weights and computing their sum
prediction = np.sum(layer_2_output * output_weights)

# Print the prediction value
print("Prediction:", prediction)